# 内容概述

- 用于表示的方法：这里介绍了`__repr__`方法和`__repr__`方法，还有`__bytes__`和`__format__`。
  - repr():会调用`__repr__`方法，以便于开发者理解的方式返回对象的字符串表示方式。
  - str():会调用`__str__`方法，以便于用户理解的方式返回对象的字符串表示方式。
  - bytes ():会调用` __bytes__` 方法，生成实例的二进制表示形式。
  - 内置的 format() 函数和 `str.format()` 方法把各个类型的格式化方式委托给相应的`.__format__(format_spec) `方法。
  - repr()和eval()为逆方法
  - 在解释器里直接输入一个类，显示时调用的是`__repr__`，print一个类的时候，调用的是`__str__`。
- classmethod装饰器：备选构造方法会用到classmethod装饰器。classmethod的用法是定义操作**类**，而不是操作**实例**的方法。这个方法很常用。不管怎样调用classmethod装饰的方法，它的第一个参数始终是类本身。
- staticmethod 装饰器：staticmethod 装饰器不是不可替代的，和其他语言中的静态函数是一回事。
- 可散列：如果要使对象变成可散列的，需要实现`__hash__`和`__eq__`，为了实现`__hash__`，要让值不可变。
- 私有属性：Python不能实现绝对的私有属性，用一个下划线表示私有变量即可。
- `__slots__`类属性节省空间：可以节约资源，但是也是存在副作用的。<a href='http://pandas.pydata.org'>pandas</a>是实现相同功能时很好的选择。
- 覆盖类属性：类属性可用于为实例属性提供默认值。实例的属性可以覆盖类属性。
  - 如果为不存在的实例属性赋值，会新建实例属性。
  - 在没在实例中修改属性的情况下，无论对象是否可变，实例和类中的属性对象是一回事。
  - 对不可变对象（如数字），在一个实例里更改这个对象，不会影响在另一个实例里的值。
  - 对可变对象（如list），在一个实例里更改这个对象，会影响在另一个实例里的值（没有新建对象）。
  - 想要修改类属性的值/全部实例的默认参数，必须直接在类上修改。
- 作者提到了一种修改数据属性的方法：创建一个只用于定制类的数据属性的子类。
- 在自定义`__repr__`，`__str__`时，不要硬编码类名，不然继承后不好用。
- 者在杂谈部分举例，说明可以在JAVA中，获取私有对象的引用，并对它进行修改。作者认为通过代码来杜绝恶意访问不是主要目的，能标注出“这个变量不希望被公开修改”就足够了。
- **<a href='https://docs.python.org/3/library/string.html#formatspec'>格式规范微语言</a>**用的时候要学习。



# 对象表示形式

这里介绍了获取对象的字符串表示形式的标准方式。

- repr():以便于开发者理解的方式返回对象的字符串表示方式。对用于`__repr__`方法。
- str():以便于用户理解的方式返回对象的字符串表示方式。对用于`__str__`方法。

此外，相关的方法还有`__bytes__`,`__format__`。

bytes 函数会调用` __bytes__` 方法，生成实例的二进制表示形式。

在解释器里直接输入一个类，显示时调用的是`__repr__`

print一个类的时候，调用的是`__str__`

**repr()和eval()为逆方法**



书上的例程有一个地方很有意思：

```python
class Vector2d:
    typecode = 'd' 
    def __init__(self, x, y):
        self.x = float(x) 
        self.y = float(y)
    def __iter__(self):
        return (i for i in (self.x, self.y)) 
    def __repr__(self):
        class_name = type(self).__name__
    return '{}({!r}, {!r})'.format(class_name, *self) 
    def __bytes__(self):
        return (bytes([ord(self.typecode)]) + 
        bytes(array(self.typecode, self)))
```

第二行暂时不细究。

第十行的`*self`很有意思，可以这么做是因为类实现了`__iter__`。

`__bytes__`实现中，为了生成字节序列，我们把 typecode 转换成字节序列，然后………迭代 Vector2d 实例，得到一个数组，再把数组转换成字节序列。



# classmethod与staticmethod

备选构造方法会用到classmethod装饰器。

下面为一个从字节码构造函数的方法：

![image-20200626090026857](E:%5CMDNotes%5CFLUENT%20PYTHON%5CCH9.assets%5Cimage-20200626090026857.png) 

classmethod的用法是定义操作**类**，而不是操作**实例**的方法。classmethod 改变了调用方法的方式，因此类方法的第一个参数是类本身，而不是实例。

staticmethod 装饰器也会改变方法的调用方式，但是第一个参数不是特殊的值。其实，静态方法就是普通的函数，只是碰巧在类的定义体中，而不是在模块层定义。(*和其他语言中的静态函数是一回事*)

下面是一个调用两个装饰器修饰过函数的例子：

![image-20200626142857433](E:%5CMDNotes%5CFLUENT%20PYTHON%5CCH9.assets%5Cimage-20200626142857433.png) 

![image-20200626142911261](E:%5CMDNotes%5CFLUENT%20PYTHON%5CCH9.assets%5Cimage-20200626142911261.png) 

***不管怎样调用 Demo.klassmeth，它的第一个参数始终是 Demo 类。***没有不得不使用staticmethod的情况，它是可替代的。



# 格式化显示

内置的 format() 函数和 `str.format()` 方法把各个类型的格式化方式委托给相应的`.__format__(format_spec) `方法。`format_spec `是格式说明符，它是：

- `format(my_obj, format_spec)` 的第二个参数，或者
- `str.format()` 方法的格式字符串，{} 里代换字段中冒号后面的部分

常见示例：

```python
>>> brl = 1/2.43 
>>> brl
0.4115226337448559
# 1 ==========
>>> format(brl, '0.4f') 
'0.4115'
# 2 ==========
>>> '1 BRL = {rate:0.2f} USD'.format(rate=brl) 
'1 BRL = 0.41 USD'

```

两句中，格式说明符分别是`'0.4f'`和`'0.2f'`。<u>第二句中的`rate`是字段名称</u>，格式说明符使用的表示法叫<a href='https://docs.python.org/3/library/string.html#formatspec'>格式规范微语言</a>。（***<u>有时间看看</u>***）（<u>`'{0.mass:5.3e}'`这个没看懂，没注意过以前有没有过类似的表示</u>）

具体的还是用的时候再上上面的链接去看吧。

```python
>>> format(42, 'b')
'101010'
>>> format(2/3, '.1%')
'66.7%'

```

此外，格式规范微语言是可扩展的，每个类可以通过定义`__format__` 方法控制返回的字符串来定制扩展，如果类没有定义 `__format__` 方法，从 object 继承的方法会返回 str(my_object)。



下面就是一个标准库中自定义的实例。

```python
>>> from datetime import datetime
>>> now = datetime.now()
>>> format(now, '%H:%M:%S')
'18:49:05'
>>> "It's now {:%I:%M %p}".format(now)
"It's now 06:49 PM"

```

`{:%I:%M %p}`里面第一个`:`和后面的`:`不一样，有点像`{rate:0.2f}`里的`:`。

具体工作可以看书。



# 可散列

只有可散列的对象才能放进`set`，如果要使对象变成可散列的，需要实现`__hash__`和`__eq__`，而且要让值不可变（这是为了实现`__hash__`）。

准备工作更改的代码：

![image-20200628114623859](E:%5CMDNotes%5CFLUENT%20PYTHON%5CCH9.assets%5Cimage-20200628114623859.png)  

实现`__hash__`可以使用位运算符异或（^）混合各分量的散列值。

代码：

```python
def __hash__(self):
    return hash(self.x) ^ hash(self.y)
```



# 私有属性和受保护属性

Python中没有private关键字，为了实现私有方法，一种解决方法是以 \_\_XXX 的形式命名私有变量。

如果以 \_\_XXX 的形式（两个前导下划线，尾部没有或最多有一个下划线）命名实例属性，Python 会在名称前面加上一个下划线和类名这叫名称改写。这种方法可以避免**误覆盖**，**但如果改写机制的规则为人所知，外人还是可以访问这样的”私有“属性，Python不能真正实现私有和不可变。**

由于这种方法并不能防止有意的改写。**Python社区约定使用一个下划线表示私有变量**。



# 使用`__slots__`类属性节省空间

## ` __dict__` 存在的问题

默认情况下，Python 在各个实例中名为` __dict__` 的字典里存储实例属性。为了使用底层的散列表提升访问速度，字典会消耗大量内存。这样做的出发点是对的，以空间换时间。`__slots__`可以对这种情况进行优化。

## ` __slots__` 原理和使用方法

**如果要处理数百万个属性不多的实例，通过` __slots__` 类属性，能节省大量内存，方法是让解释器在元组（*因为这样定义的 ` __slots__` 中所含的信息不会变化*）中存储实例属性，而不用字典。要注意的是，继承自超类的 __slots__ 属性没有效果。Python 只会使用各个类中定义的` __slots__` 属性。**

定义 ` __slots__` 的方式是，创建一个类属性，使用 ` __slots__` 这个名字，并把它的值设为一个字符串构成的可迭代对象，其中各个元素表示各个实例属性。

在类中定义 ` __slots__` 属性的目的是告诉解释器：“这个类中的所有实例属性都在这儿了！”**这样，Python 会在各个实例中使用类似元组的结构存储实例变量，从而避免使用消耗内存的 ` __dict__` 属性**。如果有数百万个实例同时活动，这样做能节省大量内存。



==**提升**==`mem_test.py`这个脚本可以用来监控python程序使用的资源。

## 副作用

- 在类中定义 `__slots__`属性之后，实例不能再有 `__slots__`中所列名称之外的其他属性。
- 不能把` __dict__` 添加到`__slots__`中，否则很明显优化会失效。
- 如果需要`__weakref__`，则需要将它手动加进`__slots__`。
- 每个子类都要定义 __slots__ 属性，因为解释器会忽略继承的 `__slots__`属性。
- `__slots__`的定位是用于处理大规模的数据，但是如果处理大规模数据，<a href='http://www.numpy.org'>NumPy</a>，<a href='http://pandas.pydata.org'>pandas</a>都是很好的选择。后者可以处理非数值数据，而且能导入 / 导出很多不同的列表数据格式。



# 覆盖类属性

Python 有个很独特的特性：类属性可用于为实例属性提供默认值。实例的属性可以覆盖类属性。

铺开来说：

- **如果为不存在的实例属性赋值，会新建实例属性**
- 在没在实例中修改属性的情况下，无论对象是否可变，实例和类中的属性对象是一回事，有着同样的id。
- 对不可变对象（如数字），在一个实例里更改这个对象，不会影响在另一个实例里的值。
- 对可变对象（如list），在一个实例里更改这个对象，会影响在另一个实例里的值（没有新建对象）。
- **想要修改类属性的值/全部实例的默认参数，必须直接在类上修改。**

```python
class A:
    L = []
    l=None

a = A()
print(a.L is A.L) # 可变对象，实例属性和类属性一致
print(a.l is A.l) # 不可变对象，实例属性和类属性一致
a.l=30
print(a.l is A.l) # 修改不可变对象后，实例属性和类属性不一致
a.L.append('123')
print(a.L is A.L) # 修改可变对象后，实例属性和类属性一致

a.ll=3
print(a.ll)       # 为不存在的实例属性赋值，会新建实例属性
print('='*10)

b = A()
print(b.L is a.L) #两个实例共享可变对象属性
print(b.l == a.l)
print(b.l is A.l) #没修改的情况下，没有建新对象

```



==**提示**==作者提到了一种修改数据属性的方法：创建一个只用于定制类的数据属性的子类。

==**提示**==作者也提示到，在自定义`__repr__`，`__str__`时，不要硬编码类名，不然继承后不好用。

==**提示**==作者在杂谈部分举例，说明可以在JAVA中，获取私有对象的引用，并对它进行修改。作者认为通过代码来杜绝恶意访问不是主要目的，能标注出“这个变量不希望被公开修改”就足够了。















































