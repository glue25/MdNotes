

# 概述

这一章主要在讲多线程/多进程。之前对这里不是很了解，借此机会可以学习。

这里主要涉及的是`concurrent.futures `模块，介绍了`future`对象的概念。

这里有些涉及下载的代码（主要用的库是`request`），还有很多`format`的代码应用。

还涉及了python显示的一些知识。

# 知识

I/O密集型应用中，使用多进程/多线程/异步都可以提速。



# concurrent.futures

concurrent.futures 模块的主要特色是 ThreadPoolExecutor 和 ProcessPoolExecutor 类。这两个类在内部维护着一个工作线程或进程池，以及要执行的任务队列。不过，这个接口抽象的层级很高，像下载国旗这种简单的案例，无需关心任何实现细节。

## future

`future` 是 `concurrent.futures` 模块和 `asyncio` 包的重要组件，但是有时不会直接用`future`。

标 准 库 中 有 两 个 名 为 `Future `的 类：`concurrent.futures.Future` 和`asyncio.Future`。这两个类的作用相同：两个 `Future` 类的实例都表示可能已经完成或者尚未完成的延迟计算。通常情况下自己不应该创建 `future`，而只能由并发框架（`concurrent.futures` 或 `asyncio`）实例化。

`Executor.submit()` 方法的参数是一个可调用的对象，调用这个方法后会为传入的可调用对象排期，并返回一个 `future`。

两种 `future` 都有 `.done() `方法，这个方法不阻塞，返回值是布尔值，指明 `future` 链接的可调用对象是否已经执行。

两个 `Future` 类都有 `.add_done_callback()` 方法：这个方法只有一个参数，类型是可调用的对象，`future` 运行结束后会调用指定的可调用对象。

此外，还有 `.result()` 方法。在 `future `运行结束后调用的话，这个方法在两个 `Future` 类中的作用相同：返回可调用对象的结果，或者重新抛出执行可调用的对象时抛出的异常。如果 `future` 没有运行结束，`result `方法在两个 `Future` 类中的行为相差很大。对`concurrency.futures.Future` 实例来说，调用 `f.result()` 方法会阻塞调用方所在的线程，直到有结果可返回。此时，result 方法可以接收可选的 `timeout` 参数，如果在指定的时间内 future 没有运行完毕，会抛出 `TimeoutError` 异常。读到 18.1.1 节会发现，`asyncio.Future.result` 方法不支持设定超时时间，在那个库中获取 `future` 的结果最好使用 `yield from `结构。不过，对 `concurrency.futures.Future` 实例不能这么做。（<u>*`concurrency.futures.Future.result()`的行为是我之前认知内的*</u>）

这两个库中有几个函数会返回 `future`，其他函数则使用 `future`，以用户易于理解的方式实现自身。`Executor.map` 方法属于后者：返回值是一个迭代器，迭代器的 `__next__` 方法调用各个 future 的 result 方法，因此我们得到的是各个 `future `的结果，而非 `future` 本身。（<u>*`concurrency.futures.Future.result()`的行为是我之前认知内的*</u>）

`concurrent.futures.as_completed` 函数数的参数是一个 `future` 列表，返回值是一个迭代器，在 `future`运行结束后产出 `future`。

# concurrent.futures示例

## 最简单的部署方法：`map`

线程/进程池`map`方法如下。在线程方法中，需要设定最大线程数。而使用进程池时不用。`map`返回的是含结果的生成器，在`map`语句多线程就已经开始了。

```python
def download_many(cc_list):
    workers = min(MAX_WORKERS, len(cc_list)) 
    with futures.ThreadPoolExecutor(workers) as executor: 
        res = executor.map(download_one, sorted(cc_list)) 
    return len(list(res))
```

第三行中，`executor.__exit__ `方法会调用`executor.shutdown(wait=True)` 方法，它会在所有线程都执行完毕前阻塞线程。也就是说只要有一个线程没执行完，程序就不会从这一步中跳出（这是符合日常认知的）。

第五行中会抛出可能的异常。

==**额外注意**==*Windows下，`ThreadPoolExecutor`要在` __name__ == '__main__'`下进行，**其他情况下使用这种方式也是好习惯***

## 更实用：使用`as_completed`

这样是更灵活的，要执行的进程在submit就开始执行了，

```python
def download_many(cc_list):
    cc_list = cc_list[:5]  # <1>
    with futures.ThreadPoolExecutor(max_workers=3) as executor:  # <2>
        to_do = []
        for cc in sorted(cc_list):  # <3>
            future = executor.submit(download_one, cc)  # <4>
            to_do.append(future)  # <5>
            msg = 'Scheduled for {}: {}'
            print(msg.format(cc, future))  # <6>

        results = []
        for future in futures.as_completed(to_do):  # <7>
            res = future.result()  # <8>
            msg = '{} result: {!r}'
            print(msg.format(future, res)) # <9>
            results.append(res)
```

2

# request示例

## 获取文件的二进制

```python
resp = requests.get(url)
image = resp.content
```



# format示例

<a href='https://www.runoob.com/python/att-string-format.html'>format菜鸟教程</a>



`str,str`

```python
url = '{}/{cc}/{cc}.gif'.format(BASE_URL, cc=cc.lower())
```
==

`int float`

```python
msg = '\n{} flags downloaded in {:.2f}s'
print(msg.format(count, elapsed))
```
==

``

```python
url = '{}/{cc}/{cc}.gif'.format(BASE_URL, cc=cc.lower())
msg = '\n{} flags downloaded in {:.2f}s'
print(msg.format(count, elapsed))

```
==

``
```python
url = '{}/{cc}/{cc}.gif'.format(BASE_URL, cc=cc.lower())
msg = '\n{} flags downloaded in {:.2f}s'
print(msg.format(count, elapsed))

```
==



# 关于python显示的一点知识

python显示都是一次输出一行。在缓冲区中遇到换行/回车才清空缓冲区，进行输出。

一种说法认为

`print(Str,end)`

等同于

`sys.stdout.write(Str+end)`

一般来说`end`默认为换行符，所以就有了常见的样子。

`sys.stdout.flush()`可以强行清空缓存区，把字符显示出来。

`\0x08`是退格，<u>使用这个可以实现在单行重复操作</u>（缺点是有时上一行字数过长，需要退格后还需要刷空格来清掉上一行）。









