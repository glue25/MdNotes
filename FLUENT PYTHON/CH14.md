哲学问题：如果用到了模式，说明抽象的不够深。

所有生成器都是迭代器，因为生成器完全实现了迭代器接口。二者实际是存在区别的，传统意义上迭代器用于从集合中取出元素，而生成器可以凭空生成。然而在 Python 社区中，大多数时候都把迭代器和生成器视作同一概念，所以不需要在这个字眼上纠结太多。

在 Python 中，所有集合都可以迭代。在 Python 语言内部，迭代器用于支持：

- for 循环
- 构建和扩展集合类型
-  逐行遍历文本文件
- 列表推导、字典推导和集合推导
- 元组拆包
- 调用函数时，使用 * 拆包实参



# 序列可迭代原因：`iter`函数

`iter`函数一般是**在需要进行迭代时候**被自动调用的，很多地方都在被使用，但是在代码明面上并不常见。

内置的 iter 函数有以下作用。

- 检查对象是否实现了` __iter__` 方法，如果实现了就调用它，获取一个迭代器。
- 如果没有实现 ` __iter__` 方法，但是实现了` __getitem__` 方法，Python 会创建一个迭代器，尝试按顺序（<u>从索引 0 开始</u>）获取元素。
- 如果尝试失败，Python 抛出 TypeError 异常，通常会提示“C object is not iterable”（C对象不可迭代），其中 C 是目标对象所属的类。

任何 Python 序列都可迭代的原因是，它们都实现了 ` __getitem__` 方法。其实，标准的序列也都实现了 ` __iter__`方法。**之所以对 ` __getitem__` 方法做特殊处理，是为了向后兼容，而未来可能不会再这么做。**

检查对象 x 能否迭代，最准确的方法是：调用 iter(x)函数，如果不可迭代，再处理 TypeError 异常。但是往往不需要

**可迭代对象**可能无法通过`issubclass (Sentence, abc.Iterable)` 测试，这是因为没有实现` __iter__` 方法。

检查对象 x 是否为**迭代器**最好的方式是调用 isinstance(x, abc.Iterator)。

## 小结

可迭代对象包括

1. 实现了` __iter__` (要返回一个迭代器)。
2. 实现了` __getitem__` ，并且可以从索引0开始获取元素。

定义的时候，即便已经实现了` __getitem__` 并且下标满足需求，最好还是要实现` __iter__` 。

使用前，不需要显示检查是否能迭代。

使用时，**解释器会自动调用`iter()`**。

# 可迭代的对象与迭代器的对比

**<u>Python 从可迭代的对象中获取迭代器</u>**

我认为，**<u>真正在被用的都是迭代器</u>**。

标准迭代器的接口有两个：

- `__next__`返回下一个可用的元素，如果没有元素了，抛出 StopIteration 异常。
- `__iter__`返回 self，以便在应该使用可迭代对象的地方使用迭代器，例如在 for 循环中。(*<u>因为已经是迭代器了，如果不是迭代器`__iter__`不能返回 self</u>*)

可迭代对象包括：

1. 实现了` __iter__` ，要返回一个迭代器实例。
2. 实现了` __getitem__` ，并且可以从索引0开始获取元素。

Iterable是Iterator的父类，collections.abc.Iterator 抽象基类中制定了 `__next__`抽象方法。

具体的 `Iterable.__iter__ `方法应该返回一个 Iterator 实例。具体的 Iterator 类必须实现 `__next__`方法。`Iterator.__iter__` 方法直接返回实例本身。

## 小结

可迭代的对象与迭代器间的关系有点复杂，从实战的角度，有几点我觉得需要注意：

- 写可迭代对象时，最好手动写出` __iter__` ，` __iter__` **要返回迭代器**

- 写迭代器时，` __iter__` 返回自身就好，`__next__`要自己实现。对`__next__`，如果没有可返回的元素了，最好抛出异常，例如：

  ```python
  except IndexError:
      raise StopIteration()
  ```
- 迭代器每次用完都需要重构，可迭代对象不需要。迭代器是真正在干活的那个。

==**土尧暴论**==：可迭代对象就是调用` __iter__` 的时候能返回一个实现了`__next__`方法对象的对象。哪怕返回对象的 ` __iter__`不能工作都不要紧，下面是例子。**这个对象（B的对象）是真正在干活的，一次性的。如果它也能实现` __iter__` ，那就可以被叫为迭代器**。

```python
class B:
    def __init__(self,l):
        super().__init__()
        self.l = l
        self.n=0
    def __next__(self) :
        if self.n<self.l :
            self.n += 1
            return self.n
        else : 
            self.n = 0
            raise StopIteration()
    def __iter__(self):
        return 0
class A:
    def __iter__(self):
        return B(10)
```



# for循环

下面两段代码可以达到相同的效果，可以从中看一下for循环的原理。

```python
>>> s = 'ABC'
>>> for char in s:
... print(char)
...
A
B
C

```

 

```python
>>> s = 'ABC'
>>> it = iter(s) # 构建迭代器
>>> while True:
... try:
...     print(next(it)) # 不断在迭代器上调用 next 函数，获取下一个字符。
... except StopIteration: # 如果没有字符了，迭代器会抛出 StopIteration 异常。
...     del it # 释放对 it 的引用，即废弃迭代器对象。
...     break # 退出循环。
...
A
B
C

```

==**土尧暴论**==：for循环是使用迭代器最常见的场景。可以看到，能被for循环使用的迭代器要实现：**`__iter__`返回一个对象，并且这个对象实现了能抛异常（StopIteration）的`__next__`**。



# 典型的迭代器

《设计模式：可复用面向对象软件的基础》一书给出的模型是**典型的迭代器模型**，**但不符合Python习惯的做法**。

简单说，**这个方法的大概思路就是让设计一个迭代器来让可迭代对象返回**。

迭代器模式可用来：

- 访问一个聚合对象的内容而无需暴露它的内部表示
- **支持对聚合对象的多种遍历**
- 为遍历不同的聚合结构提供一个统一的接口（即支持多态迭代）

正确的方法是每次都**返回一个独立的迭代器**（不过对Python，要用生成器函数替代手动写的生成器）。



# 备注

```python
RE_WORD = re.compile('\w+')
self.words = RE_WORD.findall(text)
```

- re.findall 函数返回一个字符串列表，里面的元素是正则表达式的全部非重叠匹配。
- reprlib.repr 这个实用函数用于生成大型数据结构的简略字符串表示形式，默认最多生成30个字符。
- **生成器是会自己抛`StopIteration`的**





9.

P337，迭代器用完要重构。重构方法是用iter和之前的iterable对象返回一个新的迭代器。用iter处理迭代器本身是没用，因为它只是return self。

10.

P337里面说的第二个方法里，为了实现__iter__，专门给它写了一个用来返回的迭代器。写的迭代器里，分别实现了__next__和__iter__，其中__next__完全按照行为描述了一个迭代器，当然这也要__init__函数的协助。总之这一版很多代码在处理迭代器的内部状态。

11.

有时候构建可迭代对象就足够了，换言之不能实现__next__，__iter__也不是只返回自己。

12.

P339，第三版是用生成器函数代替第二版中的自己写的迭代器类。写法见截图【】。

13.

P340，yield函数是生成器工厂。

生成器理解成一次只触发一个yield，产生一个值？执行完毕后，它会抛出StopIteration异常。

14.

P343，代码更简短了，大概是用了finditer的API。其实也可以用生成器表达式（如下文）。

15.

P344，一开始没理解为什么是AAA,BBB,其实把它想成一个普通的迭代器就好了。

另一个值得注意的地方就是列表推导的输出结果和生成器表达式的区别。列表推导会马上“执行”生成器来获取结果。而生成器推导时，生成器不会马上执行，当进入for之后，原生成器才会工作。

16.

生成器函数和生成器表达式是等效的，有时后者更便利。

P345是生成器表达式版的代码

17.

P347的代码我应该自己也能写出来。

18.

P348，itertools模块里提供了很多生成器函数。

【把图截过来！！】

【自己实践一下，看看有没有哪些是可替代的关系！！】

19.

P357，yield from是从迭代器的迭代器里产生值，看起来像语法糖，但后面还有别的用。

20.

归约函数：输入一个可迭代的对象，返回单个结果。

【贴图】

【并补上sorted】

21.

iter+哨符看起来很酷炫，相当于对于一个函数，进行“满足条件就停止”的限制。

【贴例程】

22.

协程和迭代无关。

.send()，可以让生成器前进到下一个yield，不管给send()的是什么参数，这个值都会成为对应yield产生的值。