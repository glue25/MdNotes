# 内容概述

- `iter`函数一般是**在需要进行迭代时候**被自动调用的，很多地方都在被使用，但是在代码明面上并不常见。

- 满足两个条件之一就可称为可迭代对象：` __iter__` 方法可以返回一个迭代器，或者实现了` __getitem__` ，并且可以从索引0开始获取元素。

- 自定义时，哪怕已经实现了下标满足需求的` __getitem__` ，最好还是要实现` __iter__` 。

- 不需要在使用前显示检查是否能迭代。

- 可迭代对象和迭代器的关系：

  - Iterable是Iterator的父类
  - 标准迭代器的接口有两个
    - `__next__`返回下一个可用的元素，如果没有元素了，抛出 StopIteration 异常。
    - `__iter__`返回 self（迭代器）
  - 可迭代对象就是调用` __iter__` 的时候能返回一个实现了`__next__`方法对象的对象。哪怕返回对象的 ` __iter__`不能工作都不要紧（穷人版迭代器，但是最好还是给返回对象写个正经的` __iter__`）。
  - 把可迭代对象比作学者，那迭代器就是在一线干活的学者（博士，博后，青椒，...）

- 简单了解了下for循环的原理

  - for循环潜在的工作：调用` __iter__` 、调用`__next__`、处理StopIteration。
  - 能被for循环使用的迭代器要实现：**`__iter__`返回一个对象，并且这个对象实现了能抛异常（StopIteration）的`__next__`**。

- 典型可迭代对象：大概思路就是让设计一个迭代器来让可迭代对象返回。

  - 迭代器模式可用来：
    - 访问一个聚合对象的内容而无需暴露它的内部表示
    - **支持对聚合对象的多种遍历**
    - 为遍历不同的聚合结构提供一个统一的接口（即支持多态迭代）
  - Python中，用生成器和生成器表达式可以更简洁。

- Python中

  

- 介绍了很多标准库中的生成器函数，当成字典来查就好了。
- 简介了yield from，这里yield from的一个用途是从嵌套的迭代器中取值。
- 介绍了常见的归约函数，`any`，`all`，`reduce`比较值得留意。
- 介绍了`iter`函数的哨符，这是个标记值，当可调用的对象返回这个值时，触发迭代器抛出 StopIteration 异常，而不产出哨符。（*遇到哨符就停止*）
- 介绍了些零散的知识、
  - re.findall 函数返回一个字符串列表，里面的元素是正则表达式的全部非重叠匹配。
  - reprlib.repr 这个实用函数用于生成大型数据结构的简略字符串表示形式，默认最多生成30个字符。
  - re.finditer 函数是 re.findall 函数的惰性版本，返回的不是列表，而是一个生成器。
  - **生成器是会自己抛`StopIteration`的**
  - 生成器表达式是生成器函数的语法糖。
- 给出了两个减少计算累计误差的方法。
- 本章最后介绍了一个实例，有空要学习。