# 摘要

**metaclass** （元类）这个词，只是模糊地描述了一种髙于类，而又超乎类的概念。简单来说，就是我们可以把Python的class语句转译为元类，并令其在每次定义具体的类时， 都提供独特的行为。

Python可以动态地定义对属性的访问操作。



# 第29条：用纯属性取代get和set方法

一般在类中配置getXXX和setXXX方法是很常见的，但是在Python中很少这么做。

如果想实现类似前面两种方法的安全赋值/取值版本方法，可以使用**@property修饰器和setter方法**。前者实现了安全访问，后者被调用时会调用被装饰器装饰的变量同名方法，里面会执行很多语句，起到了替代原有**set方法**的作用。

**<u>这两个装饰器可以实现：定义访问对象的某个属性时，需要表现出特殊的行为</u>**



例如：

![image-20200707235738810](E:%5CMDNotes%5CEFFECTIVE%20PYTHON%5C%E7%AC%AC4%E7%AB%A0_%E5%85%83%E7%B1%BB%E5%8F%8A%E5%B1%9E%E6%80%A7.assets%5Cimage-20200707235738810.png) 

下面这个例子里，这种方法可以保护属性不被更改。
![image-20200708000918541](E:%5CMDNotes%5CEFFECTIVE%20PYTHON%5C%E7%AC%AC4%E7%AB%A0_%E5%85%83%E7%B1%BB%E5%8F%8A%E5%B1%9E%E6%80%A7.assets%5Cimage-20200708000918541.png) 

*<u>@property的最大缺点在于：和属性相关的方法，只能在子类里面共享，而与之无关的其他类，则无法复用同一份实现代码。不过，Python也提供了描述符机制(参见本书第31条)，开发者可以通过它来复用与属性有关的逻辑，此外，描述符还有其他一些用法。</u>*（没太理解）



不要在里面做多余的事情，做传统意义上该做的事就好。@property方法需要执行得迅速一些。



# 第30条：考虑用@property来代替属性重构

@property还有一种 高级的用法，就是可以把简单的数值属性迁移为实时计算(on-the-fly calculation,按 需计算、动态计算)的属性。

***<u>说到底还是实现定义访问对象的某个属性时，需要表现出特殊的行为吧</u>***



*<u>在处理实际工作中的代码时，@property固然是一项非常有效的工具，但是也不能滥用。如果你发现自己正在不停地编写各种@property方法，那恐怕就意味着当前这个类的代码写得确实很差。此时，应该彻底重构该类，而不应该继续修补这套糟糕的设计。</u>*

@property可以为现有的实例属性添加新的功能。

87543914