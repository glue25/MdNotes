# 3 函数

## 3.1 短小

函数的缩进不应多于一层/两层

作者也提到`if`，`else`，`while`内应该只有一行，不过这个要求有些偏激

目前还是尽可能写短吧



## 3.2 只做一件事

函数应该做一件事。做好这件事。只做这一件事。 

只做一件事的函数无法被合理分为多个区段



## 3.3 每个函数一个抽象层级 

要确保函数只做一件事，函数中的语句都要在同一抽象层级上。

函数中混杂不同抽象层级，往往让人迷惑。读者可能无法判断某个表达式是基础概念还是细节。更恶劣的是，就像破损的窗户，一旦细节与基础概念混杂，更多的细节就会在函数中纠结起来。



我们想要让代码拥有自顶向下的阅读顺序。1我们想要让每个函数后面都跟着位于下一抽象层级的函数，这样一来，在查看函数列表时，就能循抽象层级向下阅读了。我把这叫做向下规则。（**这个建议很有意思**）



## 3.4 switch 语句



写出只做一件事的switch语句也很难。Switch天生要做N件事。

该问题的解决方案(如代码清单3-5所示)是将switch语句埋到抽象工厂底下，不让任何人看到。该工厂使用switch语句为Employee的派生物创建适当的实体，而不同的函数，如calculatePay、isPayday和deliverPay等，则藉由Employee接口多态地接受派遣。 

对于switch语句，我的规矩是如果只出现一次，用于创建多态对象，而且隐藏在某个继承关系中，在系统其他部分看不到，就还能容忍[G23]。当然也要就事论事，有时我也会部分或全部违反这条规矩。 

（**这个还需要理解，大概是把switch放在底层**）

```java
public abstract class Employee { 
	public abstract boolean isPayday();
	public abstract Money calculatePay();
	public abstract void deliverPay(Money pay);
}
// -----------------------------------------------------------
public interface EmployeeFactory { 
	public Employee makeEmployee(EmployeeRecord r) throws InvalidEmployeeType; 
}	
// -----------------------------------------------------------
public class EmployeeFactorylmpl implements EmployeeFactory { 
	public Employee makeEmployee(EmployeeRecord r) throws InvalidEmployeeType {
		switch (r.type) { 
			case COMMISSIONED:
				return new CommissionedEmployee(r);
			case HOURLY:
				return new HourlyEmployee(r); 
			case SALARIED:
				return new SalariedEmploye(r); 
			default:
				throw new InvalidEmployeeType(r.type); 
			} 
		} 
	}
}
```



## 3.5使用描述性的名称 

在代码清单3-7中，我把示例函数的名称从testableHtml改为SetupTeardownIncluder.render。这个名称好得多，因为它较好地描述了函数做的事。我也给每个私有方法取个同样具有描述性的名称，如isTestable或includeSetupAndTeardownPageso好名称的价值怎么好评都不为过。记住沃德原则：“**如果每个例程都让你感到深合己意，那就是整洁代码**。”



## 3.6 函数参数

**参数要少**

最理想的参数数量是零（零参数函数），其次是一（单参数函数），再次是二（双参数函数），应尽量避免三（三参数函数）。有足够特殊的理由才能用三个以上参数（多参数函数），所以无论如何也不要这么做。 

（*<u>但是有时要设定很多模式，这个要怎们办？</u>*）



















